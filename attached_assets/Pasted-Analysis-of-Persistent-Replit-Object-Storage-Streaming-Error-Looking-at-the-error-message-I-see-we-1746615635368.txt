Analysis of Persistent Replit Object Storage Streaming Error
Looking at the error message, I see we're still encountering the same issue even after the initial fix:

Error retrieving file temp/BluePots_1746615438699.jpg: Error: Failed to create stream after 2 attempts: Cannot read properties of undefined (reading 'on')
This indicates that the issue is more fundamental in how we're handling the file streaming from Replit's Object Storage.

VeriTrade's Working Implementation
Let me propose a completely different approach based on VeriTrade's working implementation:

1. Direct Buffer Approach Instead of Streaming
In VeriTrade.shop, we don't use the streaming approach for temporary files. Instead, we:

Upload the file to Object Storage
When we need to serve it, we get the complete file as a buffer
Set the appropriate headers and send the buffer directly
Here's how to implement this without changing your main application logic:

// In your objectstore.ts or similar file
class ObjectStorageService {
  // Keep existing methods, but add/modify these:
  
  async getFileAsBuffer(key) {
    try {
      // Get the file directly as a buffer instead of streaming
      const data = await this.objectStore.get(key);
      if (!data) {
        throw new Error(`File not found: ${key}`);
      }
      
      // Detect content type based on file extension
      const contentType = this.getContentTypeFromKey(key) || 'application/octet-stream';
      
      return {
        data,
        contentType
      };
    } catch (error) {
      console.error(`Error getting file as buffer: ${key}`, error);
      throw error;
    }
  }
  
  getContentTypeFromKey(key) {
    const extension = key.split('.').pop().toLowerCase();
    const mimeTypes = {
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'png': 'image/png',
      'gif': 'image/gif',
      'webp': 'image/webp',
      // Add other types as needed
    };
    return mimeTypes[extension] || null;
  }
}
2. Modified API Route to Use Buffer Instead of Stream
// In your routes.ts or similar file
app.get('/api/files/temp/:filename', async (req, res) => {
  try {
    const key = `temp/${req.params.filename}`;
    
    // Use buffer approach instead of stream
    const { data, contentType } = await objectStorageService.getFileAsBuffer(key);
    
    // Set appropriate headers
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Length', data.length);
    
    // Send the buffer directly
    res.send(data);
  } catch (error) {
    console.error(`Error serving temp file: ${req.params.filename}`, error);
    res.status(500).send('Error retrieving file');
  }
});
3. Modified Upload Handler
app.post('/api/products/images/temp', upload.single('file'), async (req, res) => {
  try {
    // Read file as buffer
    const fileBuffer = await fs.promises.readFile(req.file.path);
    const tempKey = `temp/${req.file.filename}`;
    
    // Upload to object storage with metadata
    await objectStorageService.objectStore.set(tempKey, fileBuffer, {
      metadata: {
        contentType: req.file.mimetype,
        originalname: req.file.originalname,
        size: req.file.size
      }
    });
    
    // Success response with the URL to access the temp file
    res.status(200).json({
      success: true,
      files: [{
        filename: req.file.filename,
        url: `/api/files/temp/${req.file.filename}`
      }]
    });
  } catch (error) {
    console.error('Error uploading file:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    // Clean up the temporary file
    if (req.file && req.file.path) {
      fs.unlink(req.file.path, (err) => {
        if (err) console.error('Error removing temp file:', err);
      });
    }
  }
});
4. Fix for the ObjectStore initialization
One additional issue might be that the Object Store is not properly initialized. Make sure you have this in your server startup:

import { ObjectStore } from '@replit/object-storage';
// Initialize at the top level with proper error handling
let objectStore;
try {
  objectStore = new ObjectStore();
  console.log('Object store initialized successfully');
} catch (error) {
  console.error('Failed to initialize object store:', error);
  // Implement fallback or exit strategy if critical
}
// Make it available to your services
const objectStorageService = new ObjectStorageService(objectStore);
Key Differences from Previous Approach
No Streaming: We completely avoid using streams and the .on method that's causing the error
Complete Buffers: We work with complete file buffers rather than streaming
Proper Initialization: We ensure the object store is properly initialized once at startup
Error Handling: We have robust error handling at every step
This approach closely mirrors what we use in VeriTrade.shop for handling temporary files during upload processes. It's been proven to work reliably with Replit's Object Storage service.